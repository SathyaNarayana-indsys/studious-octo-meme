name: Security Pipeline
run-name: Commit - ${{ github.sha }} on ${{ github.ref_name }}

# This workflow is designed to be called by another workflow.
on:
  workflow_call:
    inputs:
      break_on_failure:
        description: 'Set to true for normal flow (fails on security issues) or false for emergency deployment (always proceeds).'
        required: false
        type: boolean
        default: true
      serviceVersion:
        description: 'Optional service version tag.'
        required: false
        type: string
        default: "NA"
      repo_link:
        description: 'The target repository link for reports (e.g., owner/repo).'
        required: false
        type: string
        default: ${{ vars.REPO_LINK }}
      deployment_type:
        description: 'Deployment target type (e.g., VM or Container).'
        required: false
        type: string
        default: VM
      runScript:
        description: 'In case of a VM deployment, the script to be executed on the VM.'
        required: false
        type: string
      deploymentFolder:
        description: 'The target deployment folder for VM deployments.'
        required: false
        type: string
      BuildScript:
        description: 'The custom build script to run before deployment.'
        required: false
        type: string
      DryRun:
        description: 'If true, skips deployment steps.'
        required: false
        type: boolean
        default: false
      executionRequired:
        required: false
        type: boolean
        default: false
      environmentName: 
        required: false
        type: string
        default: main

jobs:
  sast:
    name: Running SAST [BearerCLI]
    runs-on: ubuntu-latest
    outputs:
      output_json: ${{ steps.sast-output.outputs.outputJson }}
      encryption_key: ${{ steps.sast-output.outputs.encryptionKey }}
    steps:
      - name:  Checkout code
        uses: actions/checkout@v4

      - name: Run Bearer SAST
        uses: bearer/bearer-action@v2
        with:
          scanner: sast
          quiet: true
          format: json
          output: SAST-results.json
          
      - name: Encrypt and Output SAST results
        id: sast-output
        if: always()
        run: |
          if [ -f "SAST-results.json" ]; then
            # Generate a random encryption key (256-bit = 32 bytes in hex = 64 chars)
            ENCRYPTION_KEY=$(openssl rand -hex 32)
            
            # Compact the JSON
            cat SAST-results.json | jq -c . > sast-compact.json
            
            # Encrypt the results using AES-256-CBC
            openssl enc -aes-256-cbc -salt -pbkdf2 -in sast-compact.json -out sast-encrypted.bin -pass pass:"$ENCRYPTION_KEY"
            
            # Base64 encode the encrypted output for safe transport
            ENCRYPTED_DATA=$(base64 -w 0 sast-encrypted.bin)
            
            # Output the encrypted data
            echo "outputJson<<EOF" >> $GITHUB_OUTPUT
            echo "$ENCRYPTED_DATA" >> $GITHUB_OUTPUT
            echo "EOF" >> $GITHUB_OUTPUT
            
            # Output the encryption key
            echo "encryptionKey=$ENCRYPTION_KEY" >> $GITHUB_OUTPUT
            
            # Clean up temporary files
            rm -f sast-compact.json sast-encrypted.bin SAST-results.json
          else
            # Output an empty JSON object to prevent downstream errors.
            echo "outputJson={}" >> $GITHUB_OUTPUT
            echo "encryptionKey=" >> $GITHUB_OUTPUT
          fi

  sbom_generator:
    name: Running Syft [SBOM generator]
    runs-on: ubuntu-latest
    outputs:
      output_json: ${{ steps.sbom-output.outputs.outputJson }}
      encryption_key: ${{ steps.sbom-output.outputs.encryptionKey }}
    steps:
      - name:  Checkout code
        uses: actions/checkout@v4
        
      - name: Generate SBOM with Syft
        uses: anchore/sbom-action@v0
        id: syft-scan
        with:
          format: spdx-json
          output-file: sbom.json
          
      - name: Encrypt and Output SBOM results
        id: sbom-output
        if: always()
        run: |
          if [ -f "sbom.json" ]; then
            # Generate a random encryption key
            ENCRYPTION_KEY=$(openssl rand -hex 32)
            
            # Compact the JSON
            cat sbom.json | jq -c . > sbom-compact.json
            
            # Encrypt the results using AES-256-CBC
            openssl enc -aes-256-cbc -salt -pbkdf2 -in sbom-compact.json -out sbom-encrypted.bin -pass pass:"$ENCRYPTION_KEY"
            
            # Base64 encode the encrypted output
            ENCRYPTED_DATA=$(base64 -w 0 sbom-encrypted.bin)
            
            # Output the encrypted data
            echo "outputJson<<EOF" >> $GITHUB_OUTPUT
            echo "$ENCRYPTED_DATA" >> $GITHUB_OUTPUT
            echo "EOF" >> $GITHUB_OUTPUT
            
            # Output the encryption key
            echo "encryptionKey=$ENCRYPTION_KEY" >> $GITHUB_OUTPUT
            
            # Clean up temporary files
            rm -f sbom-compact.json sbom-encrypted.bin sbom.json
          else
            echo "outputJson={}" >> $GITHUB_OUTPUT
            echo "encryptionKey=" >> $GITHUB_OUTPUT
          fi

  secret_detection:
    name: Running Truffle-Hog
    runs-on: ubuntu-latest
    outputs:
      output_json: ${{ steps.secrets-output.outputs.outputJson }}
      encryption_key: ${{ steps.secrets-output.outputs.encryptionKey }}
    steps:
      - name:  Checkout code
        uses: actions/checkout@v4
        
      - name: Install and run TruffleHog
        id: truffleHog-scan
        run: |
          # Install TruffleHog
          curl -sSfL https://raw.githubusercontent.com/trufflesecurity/trufflehog/main/scripts/install.sh | sh -s -- -b /usr/local/bin
          # Run scan on the local filesystem, output JSON, suppress logs, exclude .git folder
          trufflehog filesystem ./ --json --log-level=-1 -x ./.git >> secrets-result.json
          
      - name: Encrypt and Output Secret results
        id: secrets-output
        if: always()
        run: |
          if [ -f "secrets-result.json" ]; then
            # Generate a random encryption key
            ENCRYPTION_KEY=$(openssl rand -hex 32)
            
            # Compact the JSON
            cat secrets-result.json | jq -c . > secrets-compact.json
            
            # Encrypt the results using AES-256-CBC
            openssl enc -aes-256-cbc -salt -pbkdf2 -in secrets-compact.json -out secrets-encrypted.bin -pass pass:"$ENCRYPTION_KEY"
            
            # Base64 encode the encrypted output
            ENCRYPTED_DATA=$(base64 -w 0 secrets-encrypted.bin)
            
            # Output the encrypted data
            echo "outputJson<<EOF" >> $GITHUB_OUTPUT
            echo "$ENCRYPTED_DATA" >> $GITHUB_OUTPUT
            echo "EOF" >> $GITHUB_OUTPUT
            
            # Output the encryption key
            echo "encryptionKey=$ENCRYPTION_KEY" >> $GITHUB_OUTPUT
            
            # Clean up temporary files
            rm -f secrets-compact.json secrets-encrypted.bin secrets-result.json
          else
            echo "outputJson={}" >> $GITHUB_OUTPUT
            echo "encryptionKey=" >> $GITHUB_OUTPUT
          fi

  sca:
    name: Running Grype [SCA]
    runs-on: ubuntu-latest
    outputs:
      output_json: ${{ steps.sca-output.outputs.outputJson }}
      encryption_key: ${{ steps.sca-output.outputs.encryptionKey }}
    steps:
      - name:  Checkout code
        uses: actions/checkout@v4
        
      - name: Run Grype (Anchore Scan)
        uses: anchore/scan-action@v6
        id: grype-scan
        with:
          path: "."
          only-fixed: true
          severity-cutoff: high
          output-file: sca-results.json
          output-format: json
          
      - name: Encrypt and Output SCA results
        id: sca-output
        if: always()
        run: |
          if [ -f "sca-results.json" ]; then
            # Generate a random encryption key
            ENCRYPTION_KEY=$(openssl rand -hex 32)
            
            # Compact the JSON
            cat sca-results.json | jq -c . > sca-compact.json
            
            # Encrypt the results using AES-256-CBC
            openssl enc -aes-256-cbc -salt -pbkdf2 -in sca-compact.json -out sca-encrypted.bin -pass pass:"$ENCRYPTION_KEY"
            
            # Base64 encode the encrypted output
            ENCRYPTED_DATA=$(base64 -w 0 sca-encrypted.bin)
            
            # Output the encrypted data
            echo "outputJson<<EOF" >> $GITHUB_OUTPUT
            echo "$ENCRYPTED_DATA" >> $GITHUB_OUTPUT
            echo "EOF" >> $GITHUB_OUTPUT
            
            # Output the encryption key
            echo "encryptionKey=$ENCRYPTION_KEY" >> $GITHUB_OUTPUT
            
            # Clean up temporary files
            rm -f sca-compact.json sca-encrypted.bin sca-results.json
          else
            echo "outputJson={}" >> $GITHUB_OUTPUT
            echo "encryptionKey=" >> $GITHUB_OUTPUT
          fi

  PublishOutput:
    name: Publish Security Reports
    runs-on: ubuntu-latest
    needs: [sast, sbom_generator, secret_detection, sca]
    if: always()
    steps:
      - name: Setup Git User
        run: |
          git config --global user.name "automation-bot"
          git config --global user.email "automation-bot@example.com"

      - name: ðŸ”— Clone the reports repo (using PAT)
        id: clone
        env:
          REPORTS_REPO_PAT: ${{ secrets.REPORTS_REPO_PAT }}
        run: |
          REPO_FULL="${{ inputs.repo_link }}"
          TARGET_DIR="${RUNNER_TEMP}/reports-repo"
          GIT_CLONE_URL="https://x-access-token:${REPORTS_REPO_PAT}@github.com/${REPO_FULL}.git"
          
          # Only clone if REPORTS_REPO_PAT is provided
          if [ -z "${REPORTS_REPO_PAT}" ]; then
            echo "REPORTS_REPO_PAT secret is not set. Skipping clone."
            exit 0
          fi

          echo "Cloning reports repo into $TARGET_DIR"
          git clone "${GIT_CLONE_URL}" "${TARGET_DIR}"

      - name: Prepare Reports Folder
        env:
          REPO_NAME: ${{ github.event.repository.name }}
          REPORTS_ROOT: ${{ runner.temp }}/reports-repo
        if: success() && steps.clone.outcome == 'success'
        run: |
          REPO_FOLDER="$REPORTS_ROOT/$REPO_NAME"
          echo "Creating reports folder: $REPO_FOLDER"
          mkdir -p "$REPO_FOLDER"

      - name: Decrypt and Write Reports
        env:
          SAST_REPORT: ${{ needs.sast.outputs.output_json }}
          SAST_KEY: ${{ needs.sast.outputs.encryption_key }}
          SBOM_REPORT: ${{ needs.sbom_generator.outputs.output_json }}
          SBOM_KEY: ${{ needs.sbom_generator.outputs.encryption_key }}
          SECRET_REPORT: ${{ needs.secret_detection.outputs.output_json }}
          SECRET_KEY: ${{ needs.secret_detection.outputs.encryption_key }}
          SCA_REPORT: ${{ needs.sca.outputs.output_json }}
          SCA_KEY: ${{ needs.sca.outputs.encryption_key }}
          REPO_NAME: ${{ github.event.repository.name }}
          REPORTS_ROOT: ${{ runner.temp }}/reports-repo
        if: success() && steps.clone.outcome == 'success'
        run: |
          REPO_FOLDER="$REPORTS_ROOT/$REPO_NAME"
          echo "Writing and decrypting reports to $REPO_FOLDER"
          
          # Function to decrypt data
          decrypt_report() {
            local ENCRYPTED_DATA="$1"
            local KEY="$2"
            local OUTPUT_FILE="$3"
            
            if [ -n "$KEY" ] && [ "$ENCRYPTED_DATA" != "{}" ]; then
              echo "$ENCRYPTED_DATA" | base64 -d > "${OUTPUT_FILE}.encrypted"
              openssl enc -aes-256-cbc -d -pbkdf2 -in "${OUTPUT_FILE}.encrypted" -out "$OUTPUT_FILE" -pass pass:"$KEY"
              rm -f "${OUTPUT_FILE}.encrypted"
            else
              echo "$ENCRYPTED_DATA" > "$OUTPUT_FILE"
            fi
          }
          
          # Decrypt and write SAST results
          decrypt_report "$SAST_REPORT" "$SAST_KEY" "$REPO_FOLDER/sast-results.json"
          
          # Decrypt and write SBOM results
          decrypt_report "$SBOM_REPORT" "$SBOM_KEY" "$REPO_FOLDER/sbom-results.json"
          
          # Decrypt and write Secret Detection results
          decrypt_report "$SECRET_REPORT" "$SECRET_KEY" "$REPO_FOLDER/secrets-results.json"
          
          # Decrypt and write SCA results
          decrypt_report "$SCA_REPORT" "$SCA_KEY" "$REPO_FOLDER/sca-results.json"

      - name: Commit and Push to Reports Repo
        env:
          REPORTS_REPO_PAT: ${{ secrets.REPORTS_REPO_PAT }}
        working-directory: ${{ runner.temp }}/reports-repo
        if: success() && steps.clone.outcome == 'success'
        run: |
          git add .
          if git diff --staged --quiet; then
            echo "No changes detected. Nothing to commit."
            exit 0
          fi

          CHANGED_FILES=$(git diff --staged --name-only | xargs -n1 basename | tr '\n' ', ')
          CHANGED_FILES="${CHANGED_FILES%, }"

          BRANCH_NAME="${{ github.ref_name }}"
          COMMIT_MESSAGE="${{ github.event.repository.name }}/${BRANCH_NAME} - Files: $CHANGED_FILES"

          git config user.name "automation-bot"
          git config user.email "automation-bot@example.com"

          git commit -m "$COMMIT_MESSAGE" || { echo "commit failed or nothing to commit"; exit 0; }

          REPO_FULL="${{ inputs.repo_link }}"
          AUTH_PUSH_URL="https://x-access-token:${REPORTS_REPO_PAT}@github.com/${REPO_FULL}.git"
          git remote set-url origin "${AUTH_PUSH_URL}"

          git push origin "HEAD:${BRANCH_NAME}"

          echo "Successfully pushed report changes to the reports repository."

  pre_build:
    name: Pre-Build Security Check
    runs-on: ubuntu-latest
    needs: [sast, sbom_generator, secret_detection, sca]
    if: always()
    env:
      BREAK_ON_FAILURE_FLAG: ${{ inputs.break_on_failure }}
    outputs:
      proceed: ${{ steps.check.outputs.proceed }}
    steps:
      - name: Security Output Check Step
        id: check
        run: |
          if [[ "$BREAK_ON_FAILURE_FLAG" == "true" ]]; then
            echo "BREAK_ON_FAILURE_FLAG is true: checking all security job results."
            # Check if ANY of the security jobs FAILED (result != success)
            if [[ "${{ needs.sast.result }}" != "success" ]] || \
              [[ "${{ needs.sbom_generator.result }}" != "success" ]] || \
              [[ "${{ needs.secret_detection.result }}" != "success" ]] || \
              [[ "${{ needs.sca.result }}" != "success" ]]; then
              
              echo "One or more security checks failed. Halting deployment."
              echo "proceed=false" >> $GITHUB_OUTPUT
              # Exit with non-zero code to fail this job
              exit 1 
            else
              echo "All security checks passed. Proceeding with build/deployment."
              echo "proceed=true" >> $GITHUB_OUTPUT
            fi
          else
            echo "BREAK_ON_FAILURE_FLAG is false: proceeding regardless of security job results."
            echo "proceed=true" >> $GITHUB_OUTPUT
          fi

  build:
    name: Run Custom Build Script (if it exists)
    runs-on: ubuntu-latest
    needs: pre_build
    if: |
      always() && 
      needs.pre_build.result == 'success'
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        
      - name: Run Custom Build Step
        id: build_check
        run: |
          BUILD_SCRIPT="${{ inputs.BuildScript }}"
          
          # Check if the BuildScript input is empty or "NA" (the default value)
          if [[ -z "$BUILD_SCRIPT" ]] || [[ "$BUILD_SCRIPT" == "NA" ]]; then
            echo "::notice file=custom_build::No BuildScript provided in inputs. Skipping build steps."
            echo "No custom build script was provided."
            # Exit with success (0) as requested, which is the shell's default for a successful run.
            exit 0
          fi
          
          # If the script is provided, proceed with execution
          echo "Executing custom build script: $BUILD_SCRIPT"
          
          # Ensure the script file exists
          if [ ! -f "$BUILD_SCRIPT" ]; then
            echo "::error file=custom_build::BuildScript file '$BUILD_SCRIPT' not found in the repository."
            exit 1 # Exit with failure if script file is missing
          fi
          
          # Make the script executable and run it
          chmod +x "$BUILD_SCRIPT"
          ./"$BUILD_SCRIPT"

  vm_deploy:
    name: VM Deployment Process
    needs: [build]
    if: |
      always() &&
      needs.build.result == 'success' &&
      !inputs.DryRun && 
      (inputs.deployment_type == 'VM' || inputs.deployment_type == 'vm' || inputs.deployment_type == 'Server' || inputs.deployment_type == 'server')
    uses: ./.github/workflows/VM-Deployment.yml
    with:
      runScript: ${{ inputs.runScript }}
      deploymentFolder: ${{ inputs.deploymentFolder }}
      executionRequired: ${{ inputs.executionRequired }}
      environmentName: ${{ inputs.environmentName }}
    secrets: inherit

  container_deploy:
    name: Container Deployment Process
    needs: [build]
    if: |
      always() &&
      needs.build.result == 'success' &&
      !inputs.DryRun && 
      (inputs.deployment_type == 'Container' || inputs.deployment_type == 'container' || inputs.deployment_type == 'microservice')
    uses: ./.github/workflows/Container-Deployment.yml