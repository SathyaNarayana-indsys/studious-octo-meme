name: Security Pipeline
run-name: Commit - ${{ github.sha }} on ${{ github.ref_name }}

on:
  workflow_call:
    inputs:
      break_on_failure:
        required: false
        type: boolean
        default: true # Set to true for normal flow else Set to false for extreme worst case emergency deployment
      serviceVersion: # not required but good to have
        required: false
        type: string
        default: "NA"
      repo_link:
        required: false
        type: string
        default: ${{ vars.REPO_LINK }}  #not full url
      deployment_type: # VM or Container
        required: false
        type: string
        default: VM
      runScript: # In case of a VM deployment, if any script have to be executed.
        required: false
        type: string
      deploymentFolder:
        required: false
        type: string
      BuildScript:
        required: false
        type: string
      DryRun:
        required: false
        type: boolean
        default: false
    secrets:
      REPORTS_REPO_PAT:
        required: false
      USER:
        required: false
      HOST:
        required: false
      SSH_PRIVATE_KEY:
        required: false
jobs:
    sast:
        name: Running SAST [BearerCLI] on project
        runs-on: ubuntu-latest 
        outputs:
          output_json: ${{ steps.sast.outputs.outputJson}}
        steps: 
          - name: Checkout code
            uses: actions/checkout@v4
          - name: Run Bearer SAST
            uses: bearer/bearer-action@v2
            with:
              scanner: sast
              quiet: true
              format: json
              output: SAST-results.json
          - name: output
            id: sast
            if: always()
            run: | 
              # Use a conditional command to check if the file exists before attempting to read it
              if [ -f "SAST-results.json" ]; then
                echo "outputJson<<EOF" >> $GITHUB_OUTPUT
                cat SAST-results.json | jq -c . >> $GITHUB_OUTPUT
                echo "EOF" >> $GITHUB_OUTPUT
              else
                # If the file does not exist (e.g., if Bearer failed to run entirely), 
                # output an empty JSON object to prevent downstream errors.
                echo "outputJson={}" >> $GITHUB_OUTPUT
              fi

    sbom_generator:
        name: Running Syft [SBOM generator] on project
        runs-on: ubuntu-latest
        outputs:
          output_json: ${{ steps.sbom.outputs.outputJson}}
        steps:
            - name: Checkout code
              uses: actions/checkout@v4
            - uses: anchore/sbom-action@v0
              id: syft
              with:
                format: spdx-json
                output-file: sbom.json
            - name: output
              id: sbom
              if: always()
              run: | 
                # Check if the output file was successfully created
                if [ -f "sbom.json" ]; then
                  # Use the robust multiline method to safely pass the JSON content
                  echo "outputJson<<EOF" >> $GITHUB_OUTPUT
                  cat sbom.json | jq -c . >> $GITHUB_OUTPUT
                  echo "EOF" >> $GITHUB_OUTPUT
                else
                  # If the file does not exist, output an empty JSON object to prevent 
                  # errors in the downstream 'PublishOutput' job
                  echo "outputJson={}" >> $GITHUB_OUTPUT
                fi

    secret_detection:
        name: Running Truffle-Hog on project
        runs-on: ubuntu-latest
        outputs:
            output_json: ${{ steps.secrets.outputJson }}
        steps:
            - name: Checkout code
              uses: actions/checkout@v4
            - name: install and run truffleHog
              id: truffleHog
              run: |
                curl -sSfL https://raw.githubusercontent.com/trufflesecurity/trufflehog/main/scripts/install.sh | sh -s -- -b /usr/local/bin
                trufflehog filesystem ./ --json --log-level=-1 -x ./.git>> secrets-result.json  
            - name: output
              id: secrets
              if: always()
              run: |
                # Check if the output file was successfully created
                if [ -f "secrets-result.json" ]; then
                  echo "outputJson<<EOF" >> $GITHUB_OUTPUT
                  # Read the file and compact it with jq -c .
                  cat secrets-result.json | jq -c . >> $GITHUB_OUTPUT
                  echo "EOF" >> $GITHUB_OUTPUT
                else
                  # If the file does not exist, output an empty JSON object to prevent downstream errors
                  echo "outputJson={}" >> $GITHUB_OUTPUT
                fi
    sca:
        name: Running Grype [SCA] on project
        runs-on: ubuntu-latest
        outputs:
            output_json: ${{ steps.sca.outputJson }}
        steps:
        - name: Checkout code
          uses: actions/checkout@v4
        - name: Run Anchore Scan
          uses: anchore/scan-action@v6
          id: grype
          with:
                path: "."
                only-fixed: true
                severity-cutoff: high
                output-file: sca-results.json
                output-format: json
        - name: output
          id: sca
          if: always()
          run: | 
            # Check if the output file was successfully created
            if [ -f "sca-results.json" ]; then
              # Use the robust multiline method to safely pass the JSON content
              echo "outputJson<<EOF" >> $GITHUB_OUTPUT
              cat sca-results.json | jq -c . >> $GITHUB_OUTPUT
              echo "EOF" >> $GITHUB_OUTPUT
            else
              # If the file does not exist, output an empty JSON object to prevent 
              # errors in the downstream 'PublishOutput' job
              echo "outputJson={}" >> $GITHUB_OUTPUT
            fi
    PublishOutput:
      name: Publishing output of all Steps after basic Review
      runs-on: ubuntu-latest
      needs: [sast, sbom_generator, secret_detection, sca]
      if: always()
      steps:
        - name: Setup Git User
          run: |
            git config --global user.name "automation-bot"
            git config --global user.email "automation-bot@example.com"

        - name: Clone the reports repo (using PAT)
          env:
            REPORTS_REPO_PAT: ${{ secrets.REPORTS_REPO_PAT }}
          run: |
            # inputs.repo_link should be "owner/repo" (same format used previously)
            REPO_FULL="${{ inputs.repo_link }}"
            TARGET_DIR="${RUNNER_TEMP}/reports-repo"

            # Use the PAT to authenticate. We use x-access-token so the token owner is the actor for the push.
            GIT_CLONE_URL="https://x-access-token:${REPORTS_REPO_PAT}@github.com/${REPO_FULL}.git"

            echo "Cloning reports repo into $TARGET_DIR"
            git clone "${GIT_CLONE_URL}" "${TARGET_DIR}"

        - name: Prepare Reports Folder
          env:
            REPO_NAME: ${{ github.event.repository.name }}
            REPORTS_ROOT: ${{ runner.temp }}/reports-repo
          run: |
            REPO_FOLDER="$REPORTS_ROOT/$REPO_NAME"
            echo "Creating reports folder: $REPO_FOLDER"
            mkdir -p "$REPO_FOLDER"

        - name: Write Reports
          env:
            SAST_REPORT: ${{ needs.sast.outputs.output_json }}
            SBOM_REPORT: ${{ needs.sbom_generator.outputs.output_json }}
            SECRET_REPORT: ${{ needs.secret_detection.outputs.output_json }}
            SCA_REPORT: ${{ needs.sca.outputs.output_json }}
            REPO_NAME: ${{ github.event.repository.name }}
            REPORTS_ROOT: ${{ runner.temp }}/reports-repo
          run: |
            REPO_FOLDER="$REPORTS_ROOT/$REPO_NAME"
            echo "Writing new reports to $REPO_FOLDER"
            echo "$SAST_REPORT" > "$REPO_FOLDER/sast-results.json"
            echo "$SBOM_REPORT" > "$REPO_FOLDER/sbom-results.json"
            echo "$SECRET_REPORT" > "$REPO_FOLDER/secrets-results.json"
            echo "$SCA_REPORT" > "$REPO_FOLDER/sca-results.json"

        - name: Commit and Push to Reports Repo (using PAT)
          env:
            REPORTS_REPO_PAT: ${{ secrets.REPORTS_REPO_PAT }}
          working-directory: ${{ runner.temp }}/reports-repo
          run: |
            git add .
            if git diff --staged --quiet; then
              echo "No changes detected. Nothing to commit."
              exit 0
            fi

            CHANGED_FILES=$(git diff --staged --name-only | xargs -n1 basename | tr '\n' ', ')
            CHANGED_FILES="${CHANGED_FILES%, }"

            BRANCH_NAME="${{ github.ref_name }}"  # branch name that triggered the workflow in the source repo
            COMMIT_MESSAGE="${{ github.event.repository.name }}/${BRANCH_NAME} - Files: $CHANGED_FILES"

            git config user.name "automation-bot"
            git config user.email "automation-bot@example.com"

            git commit -m "$COMMIT_MESSAGE" || { echo "commit failed or nothing to commit"; exit 0; }

            REPO_FULL="${{ inputs.repo_link }}"
            AUTH_PUSH_URL="https://x-access-token:${REPORTS_REPO_PAT}@github.com/${REPO_FULL}.git"
            git remote set-url origin "${AUTH_PUSH_URL}"

            git push origin "HEAD:${BRANCH_NAME}"

            echo "Successfully pushed report changes to the reports repository."
            echo "Commit Message: $COMMIT_MESSAGE"

    pre_build:
      name: Running Build (pre-check)
      runs-on: ubuntu-latest
      needs: [sast, sbom_generator, secret_detection, sca]
      if: always()
      env:
        BREAK_ON_FAILURE_FLAG: ${{ inputs.break_on_failure }}
      outputs:
        proceed: ${{ steps.check.outputs.proceed }}
      steps:
        - name: Debug inputs and previous job results
          run: |
            echo "DEBUG: inputs.BuildScript='${{ inputs.BuildScript }}'"
            echo "DEBUG: inputs.DryRun='${{ inputs.DryRun }}'"
            echo "DEBUG: inputs.deployment_type='${{ inputs.deployment_type }}'"
            echo "DEBUG: needs.sast.result='${{ needs.sast.result }}'"
            echo "DEBUG: needs.sbom_generator.result='${{ needs.sbom_generator.result }}'"
            echo "DEBUG: needs.secret_detection.result='${{ needs.secret_detection.result }}'"
            echo "DEBUG: needs.sca.result='${{ needs.sca.result }}'"
        - name: Security Output Check Step
          id: check
          run: |
            if [[ "$BREAK_ON_FAILURE_FLAG" == "true" ]]; then
              echo "BREAK_ON_FAILURE_FLAG is true, continuing only if all reports are successful."
              if [[ "${{ needs.sast.result }}" != "success" ]] || \
                [[ "${{ needs.sbom_generator.result }}" != "success" ]] || \
                [[ "${{ needs.secret_detection.result }}" != "success" ]] || \
                [[ "${{ needs.sca.result }}" != "success" ]]; then
                echo "One or more checks failed. Skipping build."
                echo "proceed=false" >> $GITHUB_OUTPUT
                exit 1
              fi
            else
              echo "BREAK_ON_FAILURE_FLAG is false, running build regardless of reports."
            fi
            echo "proceed=true" >> $GITHUB_OUTPUT
        - name: Debug proceed output
          if: always()
          run: |
            echo "DEBUG: pre_build step 'check' output proceed='${{ steps.check.outputs.proceed }}'"
    custom_build:
      name: Custom Build Job (invokes CustomBuild.yml)
      needs: pre_build
      if: ${{ inputs.DryRun != true && inputs.BuildScript != '' && inputs.BuildScript != null && needs.pre_build.outputs.proceed == 'true' }}
      uses: SathyaNarayana-indsys/studious-octo-meme/.github/workflows/CustomBuild.yml@main
      with:
        deployment_type:   ${{ inputs.deployment_type }}
        runScript:  ${{ inputs.runScript }}
        deploymentFolder: ${{ inputs.deploymentFolder }}
        BuildScript: ${{ inputs.BuildScript }}
      secrets:
        USER: ${{ secrets.USER }}
        HOST: ${{ secrets.HOST }}
        SSH_PRIVATE_KEY: ${{ secrets.SSH_PRIVATE_KEY }}

    direct_deploy:
      name: Direct Deploy Job (invokes DirectDeployBuild.yml)
      needs: pre_build
      if: ${{ inputs.DryRun != true && (inputs.BuildScript == '' || inputs.BuildScript == null) && needs.pre_build.outputs.proceed == 'true' }}
      uses: SathyaNarayana-indsys/studious-octo-meme/.github/workflows/DirectDeployBuild.yml@main
      with:
        deployment_type:   ${{ inputs.deployment_type }}
        runScript:  ${{ inputs.runScript }}
        deploymentFolder: ${{ inputs.deploymentFolder }}
      secrets:
        USER: ${{ secrets.USER }}
        HOST: ${{ secrets.HOST }}
        SSH_PRIVATE_KEY: ${{ secrets.SSH_PRIVATE_KEY }}
