name: Security Pipeline
run-name: Commit - ${{ github.sha }} on ${{ github.ref_name }}

# This workflow is designed to be called by another workflow.
on:
  workflow_call:
    inputs:
      break_on_failure:
        description: 'Set to true for normal flow (fails on security issues) or false for emergency deployment (always proceeds).'
        required: false
        type: boolean
        default: true
      serviceVersion:
        description: 'Optional service version tag.'
        required: false
        type: string
        default: "NA"
      repo_link:
        description: 'The target repository link for reports (e.g., owner/repo).'
        required: false
        type: string
        default: ${{ vars.REPO_LINK }}
      deployment_type:
        description: 'Deployment target type (e.g., VM or Container).'
        required: false
        type: string
        default: VM
      runScript:
        description: 'In case of a VM deployment, the script to be executed on the VM.'
        required: false
        type: string
      deploymentFolder:
        description: 'The target deployment folder for VM deployments.'
        required: false
        type: string
      BuildScript:
        description: 'The custom build script to run before deployment.'
        required: false
        type: string
      DryRun:
        description: 'If true, skips deployment steps.'
        required: false
        type: boolean
        default: false
      executionRequired:
        required: false
        type: boolean
        default: false
    secrets:
      REPORTS_REPO_PAT:
        description: 'PAT for cloning and pushing to the reports repository.'
        required: false
      USER:
        description: 'SSH user for VM deployment.'
        required: false
      HOST:
        description: 'SSH host for VM deployment.'
        required: false
      SSH_PRIVATE_KEY:
        description: 'SSH private key for VM deployment.'
        required: false

jobs:
  sast:
    name: Running SAST [BearerCLI]
    runs-on: ubuntu-latest
    # Output the SAST JSON result for downstream jobs
    outputs:
      output_json: ${{ steps.sast-output.outputs.outputJson }}
    steps:
      - name:  Checkout code
        uses: actions/checkout@v4

      - name: Run Bearer SAST
        uses: bearer/bearer-action@v2
        with:
          scanner: sast
          quiet: true
          format: json
          output: SAST-results.json
          
      - name: Output SAST results
        id: sast-output # Renamed ID for clarity
        if: always()
        run: |
          # Use a conditional command to check if the file exists before attempting to read it
          if [ -f "SAST-results.json" ]; then
            echo "outputJson<<EOF" >> $GITHUB_OUTPUT
            # Use jq to compact the JSON before outputting
            cat SAST-results.json | jq -c . >> $GITHUB_OUTPUT
            echo "EOF" >> $GITHUB_OUTPUT
          else
            # Output an empty JSON object to prevent downstream errors.
            echo "outputJson={}" >> $GITHUB_OUTPUT
          fi

  sbom_generator:
    name: Running Syft [SBOM generator]
    runs-on: ubuntu-latest
    outputs:
      output_json: ${{ steps.sbom-output.outputs.outputJson }}
    steps:
      - name:  Checkout code
        uses: actions/checkout@v4
        
      - name: Generate SBOM with Syft
        uses: anchore/sbom-action@v0
        id: syft-scan # Renamed ID for clarity
        with:
          format: spdx-json
          output-file: sbom.json
          
      - name: Output SBOM results
        id: sbom-output # Renamed ID for clarity
        if: always()
        run: |
          if [ -f "sbom.json" ]; then
            echo "outputJson<<EOF" >> $GITHUB_OUTPUT
            cat sbom.json | jq -c . >> $GITHUB_OUTPUT
            echo "EOF" >> $GITHUB_OUTPUT
          else
            echo "outputJson={}" >> $GITHUB_OUTPUT
          fi

  secret_detection:
    name: Running Truffle-Hog
    runs-on: ubuntu-latest
    # Corrected output reference: use step ID
    outputs:
      output_json: ${{ steps.secrets-output.outputs.outputJson }}
    steps:
      - name:  Checkout code
        uses: actions/checkout@v4
        
      - name: Install and run TruffleHog
        id: truffleHog-scan # Renamed ID for clarity
        run: |
          # Install TruffleHog
          curl -sSfL https://raw.githubusercontent.com/trufflesecurity/trufflehog/main/scripts/install.sh | sh -s -- -b /usr/local/bin
          # Run scan on the local filesystem, output JSON, suppress logs, exclude .git folder
          trufflehog filesystem ./ --json --log-level=-1 -x ./.git >> secrets-result.json
          
      - name: Output Secret results
        id: secrets-output # Renamed ID for clarity
        if: always()
        run: |
          if [ -f "secrets-result.json" ]; then
            echo "outputJson<<EOF" >> $GITHUB_OUTPUT
            cat secrets-result.json | jq -c . >> $GITHUB_OUTPUT
            echo "EOF" >> $GITHUB_OUTPUT
          else
            echo "outputJson={}" >> $GITHUB_OUTPUT
          fi

  sca:
    name: Running Grype [SCA]
    runs-on: ubuntu-latest
    # Corrected output reference: use step ID
    outputs:
      output_json: ${{ steps.sca-output.outputs.outputJson }}
    steps:
      - name:  Checkout code
        uses: actions/checkout@v4
        
      - name: Run Grype (Anchore Scan)
        uses: anchore/scan-action@v6
        id: grype-scan # Renamed ID for clarity
        with:
          path: "."
          only-fixed: true
          severity-cutoff: high
          output-file: sca-results.json
          output-format: json
          
      - name: Output SCA results
        id: sca-output # Renamed ID for clarity
        if: always()
        run: |
          if [ -f "sca-results.json" ]; then
            echo "outputJson<<EOF" >> $GITHUB_OUTPUT
            cat sca-results.json | jq -c . >> $GITHUB_OUTPUT
            echo "EOF" >> $GITHUB_OUTPUT
          else
            echo "outputJson={}" >> $GITHUB_OUTPUT
          fi

  PublishOutput:
    name: Publish Security Reports
    runs-on: ubuntu-latest
    needs: [sast, sbom_generator, secret_detection, sca]
    if: always()
    steps:
      - name: Setup Git User
        run: |
          git config --global user.name "automation-bot"
          git config --global user.email "automation-bot@example.com"

      - name: ðŸ”— Clone the reports repo (using PAT)
        env:
          REPORTS_REPO_PAT: ${{ secrets.REPORTS_REPO_PAT }}
        run: |
          REPO_FULL="${{ inputs.repo_link }}"
          TARGET_DIR="${RUNNER_TEMP}/reports-repo"
          GIT_CLONE_URL="https://x-access-token:${REPORTS_REPO_PAT}@github.com/${REPO_FULL}.git"
          
          # Only clone if REPORTS_REPO_PAT is provided
          if [ -z "${REPORTS_REPO_PAT}" ]; then
            echo "REPORTS_REPO_PAT secret is not set. Skipping clone."
            exit 0
          fi

          echo "Cloning reports repo into $TARGET_DIR"
          git clone "${GIT_CLONE_URL}" "${TARGET_DIR}"

      - name: Prepare Reports Folder
        env:
          REPO_NAME: ${{ github.event.repository.name }}
          REPORTS_ROOT: ${{ runner.temp }}/reports-repo
        # Check if the reports-repo directory exists before trying to create subfolders
        if: success() && steps.clone.outcome == 'success'
        run: |
          REPO_FOLDER="$REPORTS_ROOT/$REPO_NAME"
          echo "Creating reports folder: $REPO_FOLDER"
          mkdir -p "$REPO_FOLDER"

      - name: Write Reports
        env:
          SAST_REPORT: ${{ needs.sast.outputs.output_json }}
          SBOM_REPORT: ${{ needs.sbom_generator.outputs.output_json }}
          SECRET_REPORT: ${{ needs.secret_detection.outputs.output_json }}
          SCA_REPORT: ${{ needs.sca.outputs.output_json }}
          REPO_NAME: ${{ github.event.repository.name }}
          REPORTS_ROOT: ${{ runner.temp }}/reports-repo
        # Check if the reports-repo directory exists before trying to write files
        if: success() && steps.clone.outcome == 'success'
        run: |
          REPO_FOLDER="$REPORTS_ROOT/$REPO_NAME"
          echo "Writing new reports to $REPO_FOLDER"
          echo "$SAST_REPORT" > "$REPO_FOLDER/sast-results.json"
          echo "$SBOM_REPORT" > "$REPO_FOLDER/sbom-results.json"
          echo "$SECRET_REPORT" > "$REPO_FOLDER/secrets-results.json"
          echo "$SCA_REPORT" > "$REPO_FOLDER/sca-results.json"

      - name: Commit and Push to Reports Repo
        env:
          REPORTS_REPO_PAT: ${{ secrets.REPORTS_REPO_PAT }}
        working-directory: ${{ runner.temp }}/reports-repo
        # Check if the reports-repo directory exists before trying to push
        if: success() && steps.clone.outcome == 'success'
        run: |
          git add .
          if git diff --staged --quiet; then
            echo "No changes detected. Nothing to commit."
            exit 0
          fi

          CHANGED_FILES=$(git diff --staged --name-only | xargs -n1 basename | tr '\n' ', ')
          CHANGED_FILES="${CHANGED_FILES%, }"

          BRANCH_NAME="${{ github.ref_name }}"
          COMMIT_MESSAGE="${{ github.event.repository.name }}/${BRANCH_NAME} - Files: $CHANGED_FILES"

          git config user.name "automation-bot"
          git config user.email "automation-bot@example.com"

          git commit -m "$COMMIT_MESSAGE" || { echo "commit failed or nothing to commit"; exit 0; }

          REPO_FULL="${{ inputs.repo_link }}"
          AUTH_PUSH_URL="https://x-access-token:${REPORTS_REPO_PAT}@github.com/${REPO_FULL}.git"
          git remote set-url origin "${AUTH_PUSH_URL}"

          git push origin "HEAD:${BRANCH_NAME}"

          echo "Successfully pushed report changes to the reports repository."

  pre_build:
    name: Pre-Build Security Check
    runs-on: ubuntu-latest
    needs: [sast, sbom_generator, secret_detection, sca]
    if: always()
    env:
      BREAK_ON_FAILURE_FLAG: ${{ inputs.break_on_failure }}
    outputs:
      proceed: ${{ steps.check.outputs.proceed }}
    steps:
      - name: Security Output Check Step
        id: check
        run: |
          # Default to proceed=true
          echo "proceed=true" >> $GITHUB_OUTPUT

          if [[ "$BREAK_ON_FAILURE_FLAG" == "true" ]]; then
            echo "BREAK_ON_FAILURE_FLAG is true: checking all security job results."
            # Check if ANY of the security jobs FAILED (result != success)
            if [[ "${{ needs.sast.result }}" != "success" ]] || \
              [[ "${{ needs.sbom_generator.result }}" != "success" ]] || \
              [[ "${{ needs.secret_detection.result }}" != "success" ]] || \
              [[ "${{ needs.sca.result }}" != "success" ]]; then
              
              echo "One or more security checks failed. Halting deployment."
              echo "proceed=false" >> $GITHUB_OUTPUT
              # Exit with non-zero code to fail this job
              exit 1 
            else
              echo "All security checks passed. Proceeding with build/deployment."
            fi
          else
            echo "BREAK_ON_FAILURE_FLAG is false: proceeding regardless of security job results."
          fi

  custom_build:
    name: Run Custom Build Script
    runs-on: ubuntu-latest
    needs: pre_build
    # Proceed if not a DryRun AND a BuildScript input was provided
    if: ${{ !inputs.DryRun && inputs.BuildScript && needs.pre_build.outputs.proceed == 'true' }}
    steps:
      - name:  Checkout code
        uses: actions/checkout@v4
      - name: Run Custom Build Step
        run: |
          # Ensure the script is executable and then run it
          chmod +x "${{ inputs.BuildScript }}"
          ./"${{ inputs.BuildScript }}"

  vm_deploy:
    name: VM Deployment Process
    # Condition to run for VM, Server, or BareMetal deployment types
    if: ${{ !inputs.DryRun && needs.pre_build.outputs.proceed == 'true' && (inputs.deployment_type == 'VM' || inputs.deployment_type == 'vm' || inputs.deployment_type == 'Server' || inputs.deployment_type == 'BareMetal') }}
    uses: ./VM-Deployment.yml
    with:
      runScript: ${{ inputs.runScript }}
      deploymentFolder: ${{ inputs.deploymentFolder }}
      executionRequired: ${{ inputs.executionRequired }}
    secrets:
      USER: ${{ secrets.USER }}
      HOST: ${{ secrets.HOST }}
      SSH_PRIVATE_KEY: ${{ secrets.SSH_PRIVATE_KEY }}

  container_deploy:
    name: Container Deployment Process
    # Condition to run for Container deployment types
    if: ${{ !inputs.DryRun && needs.pre_build.outputs.proceed == 'true' && (inputs.deployment_type == 'Container' || inputs.deployment_type == 'container') }}
    uses: ./Container-Deployment.yml
    # Add an empty 'with' block if the container workflow requires no inputs, or add necessary inputs
    # with: 
    #   someInput: ${{ inputs.someInput }}