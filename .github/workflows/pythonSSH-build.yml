name: Build Pipeline
run-name: Commit - ${{ github.sha }} on ${{ github.ref_name }}

on:
  workflow_call:
    inputs:
      break_on_failure:
        required: false
        type: boolean
        default: true # Set to true for normal flow else Set to false for extreme worst case emergency deployment
      serviceVersion:
        required: false
        type: string
        default: "NA"
      repo_link:
        required: false
        type: string
        default: ${{ vars.repo_link }}  #not full url
    secrets:
      REPORTS_REPO_PAT:
        required: false
        
jobs:
    sast:
        name: Running SAST [BearerCLI] on project
        runs-on: ubuntu-latest 
        outputs:
          output_json: ${{ steps.sast.outputs.outputJson}}
        steps: 
          - name: Checkout code
            uses: actions/checkout@v4
          - name: Run Bearer SAST
            uses: bearer/bearer-action@v2
            with:
              scanner: sast
              quiet: true
              format: json
              output: SAST-results.json
          - name: output
            id: sast
            if: always()
            run: | 
              # Use a conditional command to check if the file exists before attempting to read it
              if [ -f "SAST-results.json" ]; then
                echo "outputJson<<EOF" >> $GITHUB_OUTPUT
                cat SAST-results.json | jq -c . >> $GITHUB_OUTPUT
                echo "EOF" >> $GITHUB_OUTPUT
              else
                # If the file does not exist (e.g., if Bearer failed to run entirely), 
                # output an empty JSON object to prevent downstream errors.
                echo "outputJson={}" >> $GITHUB_OUTPUT
              fi

    sbom_generator:
        name: Running Syft [SBOM generator] on project
        runs-on: ubuntu-latest
        outputs:
          output_json: ${{ steps.sbom.outputs.outputJson}}
        steps:
            - name: Checkout code
              uses: actions/checkout@v4
            - uses: anchore/sbom-action@v0
              id: syft
              with:
                format: spdx-json
                output-file: sbom.json
            - name: output
              id: sast
              if: always()
              run: | 
                # Use a conditional command to check if the file exists before attempting to read it
                if [ -f "SAST-results.json" ]; then
                  echo "outputJson<<EOF" >> $GITHUB_OUTPUT
                  cat SAST-results.json | jq -c . >> $GITHUB_OUTPUT
                  echo "EOF" >> $GITHUB_OUTPUT
                else
                  # If the file does not exist (e.g., if Bearer failed to run entirely), 
                  # output an empty JSON object to prevent downstream errors.
                  echo "outputJson={}" >> $GITHUB_OUTPUT
                fi

    secret_detection:
        name: Running Truffle-Hog on project
        runs-on: ubuntu-latest
        outputs:
            output_json: ${{ steps.secrets.outputJson }}
        steps:
            - name: Checkout code
              uses: actions/checkout@v4
            - name: install and run truffleHog
              id: truffleHog
              run: |
                curl -sSfL https://raw.githubusercontent.com/trufflesecurity/trufflehog/main/scripts/install.sh | sh -s -- -b /usr/local/bin
                trufflehog filesystem ./ --json --log-level=-1 -x ./.git>> secrets-result.json  
            - name: output
              id: secrets
              if: always()
              run: |
                # Check if the output file was successfully created
                if [ -f "secrets-result.json" ]; then
                  echo "outputJson<<EOF" >> $GITHUB_OUTPUT
                  # Read the file and compact it with jq -c .
                  cat secrets-result.json | jq -c . >> $GITHUB_OUTPUT
                  echo "EOF" >> $GITHUB_OUTPUT
                else
                  # If the file does not exist, output an empty JSON object to prevent downstream errors
                  echo "outputJson={}" >> $GITHUB_OUTPUT
                fi
    sca:
        name: Running Grype [SCA] on project
        runs-on: ubuntu-latest
        outputs:
            output_json: ${{ steps.sca.outputJson }}
        steps:
        - name: Checkout code
          uses: actions/checkout@v4
        - name: Run Anchore Scan
          uses: anchore/scan-action@v6
          id: grype
          with:
                path: "."
                only-fixed: true
                severity-cutoff: high
                output-file: sca-results.json
                output-format: json
        - name: output
          id: sca
          if: always()
          run: | 
            # Check if the output file was successfully created
            if [ -f "sca-results.json" ]; then
              # Use the robust multiline method to safely pass the JSON content
              echo "outputJson<<EOF" >> $GITHUB_OUTPUT
              cat sca-results.json | jq -c . >> $GITHUB_OUTPUT
              echo "EOF" >> $GITHUB_OUTPUT
            else
              # If the file does not exist, output an empty JSON object to prevent 
              # errors in the downstream 'PublishOutput' job
              echo "outputJson={}" >> $GITHUB_OUTPUT
            fi

    PublishOutput:
      name: Publishing output of all Steps after basic Review
      runs-on: ubuntu-latest
      needs: [sast, sbom_generator, secret_detection, sca]
      if: always()
      steps:
            -  name: checkout the reports repo
               uses: actions/checkout@v4
               with:
                repository: ${{ inputs.repo_link }}
                path: reports-repo
                token: ${{ secrets.REPORTS_REPO_PAT }}
            -  name: Check if Current Repo exist else Create
               id: checkFolder
               env: 
                REPO_NAME: ${{ github.event.repository.name }}
               run: |
                  echo "Checking Repo's existance and deleting it if it exists"
                  if [ -d "reports-repo/$REPO_NAME" ]; then
                    echo "folder exists, so removing it"
                  else
                    echo "creating the folders"
                    mkdir -p reports-repo/$REPO_NAME
                  fi
            -  name: copy, commit and push changes
               id: copy_reports
               env:
                SAST_REPORT: ${{ needs.sast.outputs.output_json }}
                SBOM_REPORT: ${{ needs.sbom_generator.outputs.output_json }}
                SECRET_REPORT: ${{ needs.secret_detection.outputs.output_json }}
                SCA_REPORT: ${{ needs.sca.outputs.output_json }}
                FOLDER: reports-repo/${{ github.event.repository.name }}
               run: |
                  echo "pushing files into reports Repo"

                  echo $SAST_REPORT > $FOLDER/sast-results.json
                  echo $SBOM_REPORT > $FOLDER/sbom-results.json
                  echo $SECRET_REPORT > $FOLDER/secrets-results.json
                  echo $SCA_REPORT > $FOLDER/sca-results.json
                  
                  cd reports-repo
                  echo "$(pwd)"
                  git config user.name "github-actions[bot]"
                  git config user.email "github-actions[bot]@users.noreply.github.com"
                  git add ./
                  
                  # Determine which files were changed/added (A or M status)
                  CHANGES=$(git status --porcelain | grep '^[AM]' | awk '{print $2}')

                  if [ -z "$CHANGES" ]; then
                    echo "No changed files detected."
                    CHANGED_FILES="none"
                  else
                    CHANGED_FILES=$(echo "$CHANGES" | xargs -n1 basename | tr '\n' ', ')
                    CHANGED_FILES="${CHANGED_FILES%, }"
                  fi

                  # Remove trailing comma and space
                  CHANGED_FILES="${CHANGED_FILES%, }"
                  
                  # Extract short branch name
                  BRANCH_NAME=$(echo ${{ github.ref_name }} | sed 's/refs\/heads\///')
                  
                  # Create the custom commit message
                  COMMIT_MESSAGE="Report Update: ${{ github.event.repository.name }}/${BRANCH_NAME} - Files: $CHANGED_FILES"
                  
                  git commit -m "$COMMIT_MESSAGE" 
                  git push origin main
                  echo "Successfully pushed report changes to the reports repository."
                  echo "Commit Message: $COMMIT_MESSAGE"

    build:
      name: Running Build
      runs-on: ubuntu-latest
      needs: [sast, sbom_generator, secret_detection, sca]
      if: always()
      env:
        BREAK_ON_FAILURE_FLAG: ${{ inputs.break_on_failure }}
      steps:
        - name: Conditional Build Step
          run: |
            if [[ "$BREAK_ON_FAILURE_FLAG" == "true" ]]; then
              echo "BREAK_ON_FAILURE_FLAG is true, continuing only if all reports are successful."
              if [[ "${{ needs.sast.result }}" != "success" ]] || \
                [[ "${{ needs.sbom_generator.result }}" != "success" ]] || \
                [[ "${{ needs.secret_detection.result }}" != "success" ]] || \
                [[ "${{ needs.sca.result }}" != "success" ]]; then
                echo "One or more checks failed. Skipping build."
                exit 0
              fi
            else
              echo "BREAK_ON_FAILURE_FLAG is false, running build regardless of reports."
            fi
        - run: echo "PR approved, Running Build"
    #         - name: Checkout code
    #           uses: actions/checkout@v4
    #         - name: Set up SSH Key
    #           uses: webfactory/ssh-agent@v0.9.0
    #           with:
    #             ssh-private-key: ${{ secrets.EC2_SSH_PRIVATE_KEY}}
    #         - name: Deploy
    #           run:  rsync -avz --exclude '.git' --chown=github:www-data --chmod=Dg=rwx,Fg=rwx ./ ${{ secrets.EC2_USER }}@${{ secrets.EC2_HOST }}:${{ vars.deploymentFolder }}
    #         - name: Execute script on EC2
    #           run: |
    #               ssh ${{ secrets.EC2_USER }}@${{ secrets.EC2_HOST }} << 'EOF' 
    #                 chmod +x ${{ vars.deploymentFolder }}/${{ vars.deploymentFile }}
    #                 /bin/bash ${{ vars.deploymentFolder }}/${{ vars.deploymentFile }}
    #               EOF



