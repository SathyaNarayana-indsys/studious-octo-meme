name: 'Deploy artifact to VM'
description: 'Pushes Built artifact to the Deployment Directory in AWS EC2 Instance'

inputs:
  artifactName:
    required: false
    default: "CompiledF"
  runScript:
    required: false
  deploymentFolder:
    required: false
  executionRequired:
    required: false
    default: "False"
  ServiceLanguage:
    required: false
    default: "SpringBoot"
  environmentName:
    required: false
    default: "main"
  envRegion:
    required: false
    default: "ap-south-1"
  executionType:
    required: false
    default: "Script"
  ServiceName:
    required: false
    default: ""
  ServiceDefFile:
    required: false
    default: ""

### Secrets as inputs ###
  AWS_ACCESS_KEY_ID:
    required: false
  AWS_SECRET_ACCESS_KEY:
    required: false
  INSTANCE_ID:
    required: false
  SSH_PRIVATE_KEY: #the cert data that is
    required: false
  INSTANCE_USER:
    required: false

    
runs:
  using: 'composite'
  steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Check AWS CLI version
      shell: bash
      run: aws --version

    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v5.1.1
      with:
        aws-access-key-id: ${{ inputs.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ inputs.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ inputs.envRegion }}
        output-credentials: true

    - name: Install AWS CLI Session Manager plugin
      shell: bash
      run: |
        curl "https://s3.amazonaws.com/session-manager-downloads/plugin/latest/ubuntu_64bit/session-manager-plugin.deb" -o "session-manager-plugin.deb"
        sudo dpkg -i session-manager-plugin.deb
    
    - name: Configure SSH
      shell: bash
      run: |
        mkdir -p ~/.ssh
        echo "${{ inputs.SSH_PRIVATE_KEY }}" > ~/.ssh/id_rsa
        chmod 600 ~/.ssh/id_rsa
        cat >> ~/.ssh/config << EOF
        Host ${{ inputs.INSTANCE_ID }}
          ProxyCommand sh -c "aws ssm start-session --target %h --document-name AWS-StartSSHSession --parameters 'portNumber=%p'"
          IdentityFile ~/.ssh/id_rsa
          StrictHostKeyChecking no
          User ${{ inputs.INSTANCE_USER }}
        EOF
        chmod 600 ~/.ssh/config

    - name: Download artifact(s?)
      uses: actions/download-artifact@v4
      with:
        name: ${{ inputs.artifactName }}
        path: ./artifact
    
    - name: Push Artifact via SCP over session Manager 
      shell: bash
      run: |
          scp -r ./artifact/* ${{ inputs.INSTANCE_USER }}@${{ inputs.INSTANCE_ID }}:${{ inputs.deploymentFolder }}/
    
    - name: SpringBoot Execution [If required]
      if: inputs.executionRequired == 'True' && (inputs.ServiceLanguage == 'SpringBoot' || inputs.ServiceLanguage == 'Java') && inputs.executionType == "Command"
      shell: bash
      run: |
        COMMAND_ID=$(aws ssm send-command \
          --instance-ids "${{ inputs.INSTANCE_ID }}" \
          --document-name "AWS-RunShellScript" \
          --parameters 'commands=[
              "cd ${{ inputs.deploymentFolder }}",
              "pkill -f \"java -jar\" || true",
              "nohup java -jar ${{ inputs.deploymentFolder }}/*.jar > app.log 2>&1 &",
              "sleep 5",
              "pgrep -f \"java -jar\" || (echo \"JAR failed to start, check app.log\" && exit 1)"
            ]'\
          --query 'Command.CommandId' \
          --output text
        )
        if ! aws ssm wait command-executed \
          --command-id "$COMMAND_ID" \
          --instance-id "${{ inputs.INSTANCE_ID }}"; then
          echo "::error::Command execution timed out or failed while starting the SpringBoot application"

          STATUS=$(aws ssm get-command-invocation \
            --command-id "$COMMAND_ID" \
            --instance-id "${{ inputs.INSTANCE_ID }}" \
            --query 'Status' \
            --output text 2>/dev/null || echo "Unknown")
          STATUS_OUTPUT=$(aws ssm get-command-invocation \
            --command-id "$COMMAND_ID" \
            --instance-id "${{ inputs.INSTANCE_ID }}" \
            --query 'StandardOutputContent' \
            --output text)
          STATUS_DETAILS=$(aws ssm get-command-invocation \
            --command-id "$COMMAND_ID" \
            --instance-id "${{ inputs.INSTANCE_ID }}" \
            --query 'StatusDetails' \
            --output text)

          echo "::error::Command Status: $STATUS"
          echo "::error::StatusDetails - $STATUS_DETAILS"
          echo "::error::StatusOutput - $STATUS_OUTPUT"

          exit 1
        fi

        STATUS=$(aws ssm get-command-invocation \
          --command-id "$COMMAND_ID" \
          --instance-id "${{ inputs.INSTANCE_ID }}" \
          --query 'Status' \
          --output text)
        STATUS_OUTPUT=$(aws ssm get-command-invocation \
          --command-id "$COMMAND_ID" \
          --instance-id "${{ inputs.INSTANCE_ID }}" \
          --query 'StandardOutputContent' \
          --output text)
        STATUS_DETAILS=$(aws ssm get-command-invocation \
          --command-id "$COMMAND_ID" \
          --instance-id "${{ inputs.INSTANCE_ID }}" \
          --query 'StatusDetails' \
          --output text)

        if [ "$STATUS" != "Success" ]; then
          echo "::error::Error running: 'nohup java -jar ${{ inputs.deploymentFolder }}/*.jar > app.log 2>&1 &'."
          echo "::error::StatusDetails - $STATUS_DETAILS"
          echo "::error::StatusOutput - $STATUS_OUTPUT"
          exit 1
        fi

    - name: Restarting Service on VM [AWS version]
      if: inputs.executionRequired == 'True' && inputs.executionType == 'ServiceRestart'        
      shell: bash
      run: |
        COMMAND_ID=$(aws ssm send-command \
          --document-name "AWS-RunShellScript" \
          --instance-ids "${{ inputs.INSTANCE_ID }}" \
          --parameters 'commands=[
            "cd ${{ inputs.deploymentFolder }}",
            "sudo cp ./${{ inputs.ServiceDefFile }} /etc/systemd/system/${{ inputs.ServiceDefFile }}",
            "sudo chmod +x /etc/systemd/system/${{ inputs.ServiceDefFile }}",
            "sudo systemctl daemon-reload",
            "sudo systemctl enable ${{ inputs.ServiceName }}",
            "sudo systemctl restart ${{ inputs.ServiceName }}"
          ]' \
          --query 'Command.CommandId' \
          --output text
        )
        if ! aws ssm wait command-executed \
          --command-id "$COMMAND_ID" \
          --instance-id "${{ inputs.INSTANCE_ID }}"; then
          echo "::error::Command execution timed out or failed while starting the  SpringBoot application"

          STATUS=$(aws ssm get-command-invocation \
            --command-id "$COMMAND_ID" \
            --instance-id "${{ inputs.INSTANCE_ID }}" \
            --query 'Status' \
            --output text 2>/dev/null || echo "Unknown")
          STATUS_OUTPUT=$(aws ssm get-command-invocation \
            --command-id "$COMMAND_ID" \
            --instance-id "${{ inputs.INSTANCE_ID }}" \
            --query 'StandardOutputContent' \
            --output text)
          STATUS_DETAILS=$(aws ssm get-command-invocation \
            --command-id "$COMMAND_ID" \
            --instance-id "${{ inputs.INSTANCE_ID }}" \
            --query 'StatusDetails' \
            --output text)

          echo "::error::Command Status: $STATUS"
          echo "::error::StatusDetails - $STATUS_DETAILS"
          echo "::error::StatusOutput - $STATUS_OUTPUT"

          exit 1
        fi

        STATUS=$(aws ssm get-command-invocation \
          --command-id "$COMMAND_ID" \
          --instance-id "${{ inputs.INSTANCE_ID }}" \
          --query 'Status' \
          --output text)
        STATUS_OUTPUT=$(aws ssm get-command-invocation \
          --command-id "$COMMAND_ID" \
          --instance-id "${{ inputs.INSTANCE_ID }}" \
          --query 'StandardOutputContent' \
          --output text)
        STATUS_DETAILS=$(aws ssm get-command-invocation \
          --command-id "$COMMAND_ID" \
          --instance-id "${{ inputs.INSTANCE_ID }}" \
          --query 'StatusDetails' \
          --output text)

        if [ "$STATUS" != "Success" ]; then
          echo "::error::Error running: 'nohup java -jar ${{ inputs.deploymentFolder }}/*.jar > app.log 2>&1 &'."
          echo "::error::StatusDetails - $STATUS_DETAILS"
          echo "::error::StatusOutput - $STATUS_OUTPUT"
          exit 1
        fi