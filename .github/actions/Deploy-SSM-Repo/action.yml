name: 'Deploy artifact to VM'
description: 'Syncs the repo to the Deployment Directory in AWS EC2 Instance'

inputs:
  runScript:
    required: false
    type: string
  deploymentFolder:
    required: false
    type: string
  executionRequired:
    required: false
    type: string
    default: "False"
  ServiceLanguage:
    required: false
    type: string
    default: "SpringBoot"
  environmentName:
    required: false
    type: string
    default: main
  envRegion:
    required: false
    type: string
    default: "ap-south-1"
  ServiceName:
    required: false
    type: string
    default: ""
  ServiceDefFile:
    required: false
    type: string
    default: ""
  ServiceRestart:
    required: false
    type: string
    default: "False"
  ScriptExecution:
    required: false
    type: string
    default: "False"

### Secrets as inputs ###
  AWS_ACCESS_KEY_ID:
    required: false
    type: string
  AWS_SECRET_ACCESS_KEY:
    required: false
    type: string
  INSTANCE_ID:
    required: false
    type: string
  INSTANCE_USER:
    required: false
    type: string

runs:
  using: 'composite'
  steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Extract branch name
        shell: bash
        run: echo "branch=${GITHUB_HEAD_REF:-${GITHUB_REF#refs/heads/}}" >> $GITHUB_OUTPUT
        id: extract_branch

      - name: Check AWS CLI version        
        shell: bash
        run: aws --version

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v5.1.1
        with:
          aws-access-key-id: ${{ inputs.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ inputs.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ inputs.envRegion }}
          output-credentials: true

      - name: Install AWS CLI Session Manager plugin
        shell: bash
        run: |
          curl "https://s3.amazonaws.com/session-manager-downloads/plugin/latest/ubuntu_64bit/session-manager-plugin.deb" -o "session-manager-plugin.deb"
          sudo dpkg -i session-manager-plugin.deb

      - name: Sync repo to VM [AWS version] #clone/sync repo in VM through SSM        
        shell: bash
        run: |
          COMMAND_ID=$(aws ssm send-command \
            --document-name "AWS-RunShellScript" \
            --instance-ids "${{ inputs.INSTANCE_ID }}" \
            --parameters 'commands=[
              "if [ ! -f /home/${{ inputs.INSTANCE_USER }}/.ssh/github_deploy ]; then",
              "  echo \"Deploy key not found. Please set up manually. by running [ssh-keygen -t ed25519 -C 'deployment-key' -f /home/${{ inputs.INSTANCE_USER }}/.ssh/github_deploy] \"",
              "  echo \"and then go to GitHub: Repository Settings → Deploy Keys → Add deploy key and add the key there\"",
              "  exit 1",
              "else",
              "  eval `ssh-agent -s`",
              "  ssh-add /home/${{ inputs.INSTANCE_USER }}/.ssh/github_deploy",
              "fi",
              "ssh-keyscan github.com | sort > /tmp/gh_key && grep -qF \"$(cat /tmp/gh_key)\" /home/${{ inputs.INSTANCE_USER }}/.ssh/known_hosts || cat /tmp/gh_key >> /home/${{ inputs.INSTANCE_USER }}/.ssh/known_hosts",
              "if [ ! -d \"${{ inputs.deploymentFolder }}\" ]; then",
              "  mkdir ${{ inputs.deploymentFolder }} -p",
              "fi",
              "cd ${{ inputs.deploymentFolder }}",
              "REPO_NAME=$(echo \"${{ github.repository }}\" | awk -F/ '\''{print $2}'\'')",
              "if [ ! -d \"$REPO_NAME\" ]; then ",
              " GIT_SSH_COMMAND=\"ssh -o StrictHostKeyChecking=no\" git clone git@github.com:${{ github.repository }}.git --single-branch --branch ${{ steps.extract_branch.outputs.branch }}",
              " cd $REPO_NAME",
              "else",
              " cd $REPO_NAME",
              " git fetch origin ${{ steps.extract_branch.outputs.branch }}",
              " git checkout -B ${{ steps.extract_branch.outputs.branch }} origin/${{ steps.extract_branch.outputs.branch }}",
              "fi"
            ]' \
            --query 'Command.CommandId' \
            --output text
          )
          if ! aws ssm wait command-executed \
            --command-id "$COMMAND_ID" \
            --instance-id "${{ inputs.INSTANCE_ID }}"; then
            echo "::error::Command execution timed out or failed while starting the SpringBoot application"

            STATUS=$(aws ssm get-command-invocation \
              --command-id "$COMMAND_ID" \
              --instance-id "${{ inputs.INSTANCE_ID }}" \
              --query 'Status' \
              --output text 2>/dev/null || echo "Unknown")
            STATUS_OUTPUT=$(aws ssm get-command-invocation \
              --command-id "$COMMAND_ID" \
              --instance-id "${{ inputs.INSTANCE_ID }}" \
              --query 'StandardOutputContent' \
              --output text)
            STATUS_DETAILS=$(aws ssm get-command-invocation \
              --command-id "$COMMAND_ID" \
              --instance-id "${{ inputs.INSTANCE_ID }}" \
              --query 'StatusDetails' \
              --output text)

            echo "::error::Command Status: $STATUS"
            echo "::error::StatusDetails - $STATUS_DETAILS"
            echo "::error::StatusOutput - $STATUS_OUTPUT"

            exit 1
          fi

          STATUS=$(aws ssm get-command-invocation \
            --command-id "$COMMAND_ID" \
            --instance-id "${{ inputs.INSTANCE_ID }}" \
            --query 'Status' \
            --output text)
          STATUS_OUTPUT=$(aws ssm get-command-invocation \
            --command-id "$COMMAND_ID" \
            --instance-id "${{ inputs.INSTANCE_ID }}" \
            --query 'StandardOutputContent' \
            --output text)
          STATUS_DETAILS=$(aws ssm get-command-invocation \
            --command-id "$COMMAND_ID" \
            --instance-id "${{ inputs.INSTANCE_ID }}" \
            --query 'StatusDetails' \
            --output text)

          if [ "$STATUS" != "Success" ]; then
            echo "::error::Error running: 'nohup java -jar ${{ inputs.deploymentFolder }}/*.jar > app.log 2>&1 &'."
            echo "::error::StatusDetails - $STATUS_DETAILS"
            echo "::error::StatusOutput - $STATUS_OUTPUT"
            exit 1
          fi
          
      - name: Execute script on VM [AWS version]
        if: inputs.executionRequired == 'True' && inputs.ScriptExecution == 'True'        
        shell: bash
        run: |
          COMMAND_ID=$(aws ssm send-command \
            --document-name "AWS-RunShellScript" \
            --instance-ids "${{ inputs.INSTANCE_ID }}" \
            --parameters 'commands=[
              "cd ${{ inputs.deploymentFolder }}",
              "REPO_NAME=$(echo \"${{ github.repository }}\" | awk -F/ '\''{print $2}'\'')",
              "cd $REPO_NAME",
              "chmod +x ${{ inputs.runScript }}",
              "/bin/bash ${{ inputs.runScript }}"
            ]' \
            --query 'Command.CommandId' \
            --output text
          )
          if ! aws ssm wait command-executed \
            --command-id "$COMMAND_ID" \
            --instance-id "${{ inputs.INSTANCE_ID }}"; then
            echo "::error::Command execution timed out or failed"

            STATUS=$(aws ssm get-command-invocation \
              --command-id "$COMMAND_ID" \
              --instance-id "${{ inputs.INSTANCE_ID }}" \
              --query 'Status' \
              --output text 2>/dev/null || echo "Unknown")
            STATUS_OUTPUT=$(aws ssm get-command-invocation \
              --command-id "$COMMAND_ID" \
              --instance-id "${{ inputs.INSTANCE_ID }}" \
              --query 'StandardOutputContent' \
              --output text)
            STATUS_DETAILS=$(aws ssm get-command-invocation \
              --command-id "$COMMAND_ID" \
              --instance-id "${{ inputs.INSTANCE_ID }}" \
              --query 'StatusDetails' \
              --output text)

            echo "::error::Command Status: $STATUS"
            echo "::error::StatusDetails - $STATUS_DETAILS"
            echo "::error::StatusOutput - $STATUS_OUTPUT"

            exit 1
          fi

          STATUS=$(aws ssm get-command-invocation \
            --command-id "$COMMAND_ID" \
            --instance-id "${{ inputs.INSTANCE_ID }}" \
            --query 'Status' \
            --output text)
          STATUS_OUTPUT=$(aws ssm get-command-invocation \
            --command-id "$COMMAND_ID" \
            --instance-id "${{ inputs.INSTANCE_ID }}" \
            --query 'StandardOutputContent' \
            --output text)
          STATUS_DETAILS=$(aws ssm get-command-invocation \
            --command-id "$COMMAND_ID" \
            --instance-id "${{ inputs.INSTANCE_ID }}" \
            --query 'StatusDetails' \
            --output text)

          if [ "$STATUS" != "Success" ]; then
            echo "::error::Error running: 'nohup java -jar ${{ inputs.deploymentFolder }}/*.jar > app.log 2>&1 &'."
            echo "::error::StatusDetails - $STATUS_DETAILS"
            echo "::error::StatusOutput - $STATUS_OUTPUT"
            exit 1
          fi

      - name: Restarting Service on VM [AWS version]
        if: inputs.executionRequired == 'True' && inputs.ServiceRestart == 'True'        
        shell: bash
        run: |
          COMMAND_ID=$(aws ssm send-command \
            --document-name "AWS-RunShellScript" \
            --instance-ids "${{ inputs.INSTANCE_ID }}" \
            --parameters 'commands=[
              "cd ${{ inputs.deploymentFolder }}",
              "REPO_NAME=$(echo \"${{ github.repository }}\" | awk -F/ '\''{print $2}'\'')",
              "cd $REPO_NAME",
              "if [ -f \"./${{ inputs.ServiceDefFile }}\" ]; then",
              " sudo cp ./${{ inputs.ServiceDefFile }} /etc/systemd/system/${{ inputs.ServiceDefFile }}",
              " sudo chmod +x /etc/systemd/system/${{ inputs.ServiceDefFile }}",
              "fi",
              "sudo systemctl daemon-reload",
              "sudo systemctl enable ${{ inputs.ServiceName }}",
              "sudo systemctl restart ${{ inputs.ServiceName }}"
            ]' \
            --query 'Command.CommandId' \
            --output text
          )
          if ! aws ssm wait command-executed \
            --command-id "$COMMAND_ID" \
            --instance-id "${{ inputs.INSTANCE_ID }}"; then
            echo "::error::Command execution timed out "

            STATUS=$(aws ssm get-command-invocation \
              --command-id "$COMMAND_ID" \
              --instance-id "${{ inputs.INSTANCE_ID }}" \
              --query 'Status' \
              --output text 2>/dev/null || echo "Unknown")
            STATUS_OUTPUT=$(aws ssm get-command-invocation \
              --command-id "$COMMAND_ID" \
              --instance-id "${{ inputs.INSTANCE_ID }}" \
              --query 'StandardOutputContent' \
              --output text)
            STATUS_DETAILS=$(aws ssm get-command-invocation \
              --command-id "$COMMAND_ID" \
              --instance-id "${{ inputs.INSTANCE_ID }}" \
              --query 'StatusDetails' \
              --output text)

            echo "::error::Command Status: $STATUS"
            echo "::error::StatusDetails - $STATUS_DETAILS"
            echo "::error::StatusOutput - $STATUS_OUTPUT"

            exit 1
          fi

          STATUS=$(aws ssm get-command-invocation \
            --command-id "$COMMAND_ID" \
            --instance-id "${{ inputs.INSTANCE_ID }}" \
            --query 'Status' \
            --output text)
          STATUS_OUTPUT=$(aws ssm get-command-invocation \
            --command-id "$COMMAND_ID" \
            --instance-id "${{ inputs.INSTANCE_ID }}" \
            --query 'StandardOutputContent' \
            --output text)
          STATUS_DETAILS=$(aws ssm get-command-invocation \
            --command-id "$COMMAND_ID" \
            --instance-id "${{ inputs.INSTANCE_ID }}" \
            --query 'StatusDetails' \
            --output text)

          if [ "$STATUS" != "Success" ]; then
            echo "::error::Service Restart Error."
            echo "::error::StatusDetails - $STATUS_DETAILS"
            echo "::error::StatusOutput - $STATUS_OUTPUT"
            exit 1
          fi